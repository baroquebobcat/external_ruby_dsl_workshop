<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    
    <!-- Always force latest IE rendering engine or request Chrome Frame -->
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    
    <!-- Use title if it's in the page YAML frontmatter -->
    <title>Curriculum</title>
    
    <link href="../css/normalize.css" media="screen" rel="stylesheet" type="text/css" />
<link href="../css/all.css" media="screen" rel="stylesheet" type="text/css" />
<link href="../css/syntax_highlighting.css" media="screen" rel="stylesheet" type="text/css" />
<link href="../css/curriculum.css" media="screen" rel="stylesheet" type="text/css" />
    
  </head>
  
  <body class="curriculum curriculum_index">
    <h1>External DSLs in Ruby</h1>

<h2>Schedule</h2>

<ul>
<li>8:00 - 8:50: Overview of DSLs / what we&rsquo;re doing today</li>
<li>8:50 - 9:00: break</li>
<li>9:10 - 11:30: Curriculum</li>
<li>11:30 - 12:00: Questions</li>
</ul>

<h2>Overview</h2>

<h1>Rocking the workshop</h1>

<ul>
<li>Ask questions</li>
<li>Type along w/ me</li>
<li>Notes are on external-dsl-ruby.baroquebobcat.com</li>
<li>If you&rsquo;ve got Q&rsquo;s after

<ul>
<li>twitter: @baroquebobcat</li>
<li>email: ndh@baroquebobcat.com</li>
</ul></li>
</ul>

<h1>Goals</h1>

<ul>
<li>Know when to use DSL</li>
<li>Know how to build an External DSL</li>
<li>Introduced to Compiler concepts like parsing</li>
</ul>

<h1>DSLs</h1>

<blockquote>
<p>Domain-specific languageÂ (noun): a computer programming language of limited 
expressiveness focused on a particular domain.</p>
</blockquote>

<p>&ndash; http://martinfowler.com/dsl.html</p>

<p>DSLs are languages that let you describe computation in a particular domain in a way that&rsquo;s well tailored to that domain. Often that means that they are easier to understand than the equivalent code in a general language because they have no content that&rsquo;s not related to the problem at hand.</p>

<p>There are whole bunches of them: haml, sass, arel, jQuery, SQL, graphviz, regex, rake, make, rspec, Gherkin &hellip;</p>

<h2>Internal vs External DSLs</h2>

<p>Internal DSLs are embedded in a host programming language, eg rake. External DSLs have their own syntax, so they require their own parser.</p>

<p>Examples of Internal DSLs include libraries like Rake, or Arel from ActiveRecord.</p>

<h3>Builder vs Haml</h3>

<p>Builder and Haml are both libraries that allow you to generate HTML. Haml is an External DSL. It has it&rsquo;s own syntax and parser, which allows it to have features like semantic whitespace and short ways of describing common HTMLisms.</p>

<p>Builder is an Internal DSL that builds arbitrary XML. Because it&rsquo;s an Internal DSL, it has to keep to Ruby&rsquo;s syntax, which means that it is more verbose than using Haml. But, writing the equivalent with regular imperative Ruby would be a lot more annoying and the structure of the data would be obscured more by other language constructs.</p>

<h4>Haml</h4>
<pre class="highlight haml"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div></td><td class="code"><span class="nt">%section</span><span class="nc">.container</span>
  <span class="nt">%h1</span><span class="p">=</span> <span class="s2">&quot;title&quot;</span>
  <span class="nt">%h2</span><span class="p">=</span> <span class="s2">&quot;subtitle&quot;</span>
  <span class="nc">.content</span>
    <span class="p">=</span> <span class="s2">&quot;some content&quot;</span>
</td></tr></tbody></table></pre>
<h4>Builder</h4>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div><div class="lineno">6</div></td><td class="code"><span class="n">builder</span> <span class="o">=</span> <span class="no">Builder</span><span class="o">::</span><span class="no">XmlMarkup</span><span class="nf">.new</span>
<span class="n">builder</span><span class="nf">.section</span><span class="p">(</span><span class="ss">class: </span><span class="s2">&quot;container&quot;</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">b</span><span class="o">|</span>
  <span class="n">b</span><span class="nf">.h1</span> <span class="s2">&quot;title&quot;</span>
  <span class="n">b</span><span class="nf">.h2</span> <span class="s2">&quot;subtitle&quot;</span>
  <span class="n">b</span><span class="nf">.div</span><span class="p">(</span><span class="s2">&quot;some content&quot;</span><span class="p">,</span> <span class="ss">class: </span><span class="s2">&quot;content&quot;</span><span class="p">)</span>
<span class="k">end</span>
</td></tr></tbody></table></pre>
<h3>SQL</h3>

<p>Since we&rsquo;re building a SQL implementation, I thought I&rsquo;d also show some examples for representing equivalent computations with it.</p>

<p>SQL</p>
<pre class="highlight sql"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div></td><td class="code"><span class="k">SELECT</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span>
<span class="k">FROM</span> <span class="n">persons</span>
<span class="k">WHERE</span> <span class="n">favorite_food</span> <span class="o">=</span> <span class="s1">&#39;bananas&#39;</span>
<span class="k">LIMIT</span> <span class="mi">10</span>
</td></tr></tbody></table></pre>
<p>Ruby</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div></td><td class="code"><span class="n">tables</span><span class="o">[</span><span class="s2">&quot;persons&quot;</span><span class="o">]</span><span class="nf">.select</span><span class="p">{</span><span class="o">|</span><span class="nb">p</span><span class="o">|</span><span class="nb">p</span><span class="o">[</span><span class="s2">&quot;favorite_food&quot;</span><span class="o">]==</span><span class="s2">&quot;bananas&quot;</span><span class="p">}</span><span class="o">.</span>
                  <span class="n">map</span><span class="p">{</span><span class="o">|</span><span class="nb">p</span><span class="o">|</span> <span class="p">{</span><span class="nb">name</span><span class="p">:</span> <span class="nb">p</span><span class="o">[</span><span class="s2">&quot;name&quot;</span><span class="o">]</span><span class="p">,</span> <span class="ss">age: </span><span class="nb">p</span><span class="o">[</span><span class="s2">&quot;age&quot;</span><span class="o">]</span><span class="p">}</span><span class="o">.</span>
                  <span class="n">first</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</td></tr></tbody></table></pre>
<p>Rails</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div></td><td class="code"><span class="no">Person</span><span class="nf">.where</span><span class="p">(</span><span class="ss">favorite_food: </span><span class="s1">&#39;bananas&#39;</span><span class="p">)</span><span class="o">.</span>
       <span class="nb">select</span><span class="p">(</span><span class="ss">:name</span><span class="p">,</span> <span class="ss">:age</span><span class="p">)</span><span class="nf">.limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</td></tr></tbody></table></pre>
<p>Java</p>
<pre class="highlight java"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div></td><td class="code"><span class="c1">// don&#39;t even get me started</span>
</td></tr></tbody></table></pre>
<h2>Why Use DSLs &amp; Why External specifically?</h2>

<p>As I showed in the examples above, DSLs are handy because they allow you to write programs that are closer to the problem you are trying to solve with less extraneous bits. They might not be good at solving problems outside their domain (eg: Regex for XML), but they are great at the domain they are designed for.</p>

<p>DSLs can also be a communication tool with non-technical stakeholders. When you write programs using only domain terminology, you make those programs grokable by domain experts.</p>

<p>External DSLs are especially good for this because they don&rsquo;t carry any extra features / syntax from another language.</p>

<p>DSLs allow you to represent different models of computation than your host language. The most popular languages today are imperative ones but sometimes the best way to describe a computation is not with an imperative model.</p>

<p>E.g. State Machines. State Machines in an imperative language show up as big blocks of if statements or case statements, which don&rsquo;t represent very well what you are actually modeling. State machines are all about transitions and states, not ifs or cases. With a DSL you can model those relationships more effectively.</p>

<p>Another common pattern are Production Rule Systems. An example in Ruby / Rails would be ActiveRecord&rsquo;s validations. It would be super annoying to write imperative code equivalent to <code>validates :age, inclusion: { in: 0..9 }</code>. With the validation DSL, you don&rsquo;t have to.</p>

<h2>When would you want to avoid using a DSL</h2>

<ul>
<li>DSLs are great when you have lots of code you need to write that&rsquo;s going to all look almost the same, but with some fiddly differences. Smaller domains probably don&rsquo;t need it as much.</li>
<li>Writing parsers and interpreters isn&rsquo;t intrisicly hard, but it requires a certain meta point of view and if you aren&rsquo;t used to building them it takes a bit to put your head around them.</li>
<li>DSLs add another thing to learn to a project. Learning a new language on top of groking a whole project could be challenging to new people. On the other hand, DSLs can more susinctly describe a problem domain, <em>and</em> the domain is what is complicated.</li>
<li>Maintenance: When you write a DSL, if it gets used a lot, you will have to maintain it. That means dealing with versioning, deprecation, etc&ndash;everything a language designer deals with.</li>
</ul>

<h1>What We&rsquo;re Doing.</h1>

<h2>one plus one</h2>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div></td><td class="code"><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span>
</td></tr></tbody></table></pre>
<script type="text/graphviz">
digraph hello {
  plus[label="+"];
  plus -> 1;
  plus -> 2;
}
</script>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div></td><td class="code"><span class="no">Add</span><span class="nf">.new</span> <span class="no">Int</span><span class="nf">.new</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">),</span> <span class="no">Int</span><span class="nf">.new</span><span class="p">(</span><span class="s2">&quot;2&quot;</span><span class="p">)</span>
</td></tr></tbody></table></pre><pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div></td><td class="code"><span class="c1">#=&gt; 3</span>
</td></tr></tbody></table></pre>
<h1>Hello World Transitions</h1>
<pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div></td><td class="code">(0) -&gt; (1) Tree Construction
(1) -&gt; (2) Transformation
(2) -&gt; (3) Evaluation
</td></tr></tbody></table></pre>
<h1>Tree Construction (with Parslet)</h1>

<blockquote>
<p>In order to construct the tree, we need to write a grammar
a dumb grammar for this would be</p>
</blockquote>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div></td><td class="code"><span class="n">int</span><span class="nf">.as</span><span class="p">(</span><span class="ss">:left</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">plus</span><span class="nf">.as</span><span class="p">(</span><span class="ss">:add</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">int</span><span class="nf">.as</span><span class="p">(</span><span class="ss">:right</span><span class="p">)</span>
</td></tr></tbody></table></pre>
<blockquote>
<p>which would leave us with</p>
</blockquote>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div></td><td class="code"><span class="p">{</span><span class="ss">left: </span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="ss">add: </span><span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="ss">right: </span><span class="s2">&quot;2&quot;</span><span class="p">}</span>
</td></tr></tbody></table></pre>
<h1>Transform</h1>

<blockquote>
<p>We&rsquo;d then need to transform that.
In parslet, that&rsquo;d look like this:</p>
</blockquote>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div></td><td class="code">  <span class="n">rule</span><span class="p">(</span><span class="ss">left: </span><span class="n">simple</span><span class="p">(</span><span class="ss">:l</span><span class="p">),</span>
       <span class="ss">add: </span><span class="n">simple</span><span class="p">(</span><span class="ss">:op</span><span class="p">),</span>
       <span class="ss">right: </span><span class="n">simple</span><span class="p">(</span><span class="ss">:r</span><span class="p">))</span> <span class="p">{</span> <span class="no">Add</span><span class="nf">.new</span> <span class="no">Int</span><span class="nf">.new</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="no">Int</span><span class="nf">.new</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">}</span>
</td></tr></tbody></table></pre>
<blockquote>
<p><code>rule</code> takes a pattern that matches portions of the intermediate tree, &amp; then runs the resulting block on that subtree.</p>
</blockquote>

<h1>Walking Skeleton</h1>
<pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div><div class="lineno">6</div><div class="lineno">7</div><div class="lineno">8</div><div class="lineno">9</div><div class="lineno">10</div><div class="lineno">11</div><div class="lineno">12</div><div class="lineno">13</div><div class="lineno">14</div><div class="lineno">15</div><div class="lineno">16</div><div class="lineno">17</div><div class="lineno">18</div><div class="lineno">19</div><div class="lineno">20</div><div class="lineno">21</div><div class="lineno">22</div><div class="lineno">23</div><div class="lineno">24</div><div class="lineno">25</div><div class="lineno">26</div><div class="lineno">27</div><div class="lineno">28</div><div class="lineno">29</div><div class="lineno">30</div><div class="lineno">31</div><div class="lineno">32</div><div class="lineno">33</div><div class="lineno">34</div><div class="lineno">35</div><div class="lineno">36</div><div class="lineno">37</div><div class="lineno">38</div><div class="lineno">39</div><div class="lineno">40</div><div class="lineno">41</div><div class="lineno">42</div><div class="lineno">43</div></td><td class="code">

                 .-&quot;```&quot;-.
                /         \
                |  _   _  |
                | (_\ /_) |
                (_   A   _)
                 | _____ |
                 \`&quot;&quot;&quot;&quot;&quot;`/
                  &#39;-.-.-&#39;
                   _:=:_                   \\|
            .-&quot;&quot;&quot;&quot;`_&#39;=&#39;_`&quot;&quot;&quot;&quot;-.           \///
           (`,-- -`\   /`- --,`)          (`/
           / //`-_--| |--_-`\\ \         .//
          / /(_-_  _| |_  _-_)\ \       ///
         / / (_- __ \ / __ -_) \ \     ///
        / /  (_ -_ - ^ - _- _)  \ \   ///
       / /   (_-  _ /=\ _ - _)   \ \ &#39;//
      / /     (_ -.&#39;:=:&#39;. -_)     \ \//
     (`;`     (_-&#39;  :=:  &#39;-_)      (_,&#39;
      \\.   jgs __  :=:  __
       \\\    .&#39;  `&#39;:=:&#39;`  &#39;.
        \\\  |  .--. = .--.  |
         \\\ |  (  / = \  )  |
          \\` \ _`&#39; \=/ &#39;`_ /
          ;`)  ( ;_/`v`\_; )
          |||\ | |       | |
          |\\  | |       | |
               | |       | |
               | |       | |
               | |       | |
               | |       | |
               | |       | |
              (._)       (_.)
               ||,       ,||
               ||:       :||
               ||:       :||
               ||:       :||
               ||:       :||
               ||&#39;       &#39;||
              ///)       (\\\
            .///`         `\\\.
           `//`             `\\`
</td></tr></tbody></table></pre>
<p><a href="http://www.retrojunkie.com/asciiart/health/skeleton.htm">source</a></p>

<h1>Break</h1>

<h1>Wild Card Walking Skeleton</h1>

<p>Walking Skeleton</p>

<blockquote>
<p>an implementation of the thinnest possible slice of real functionality that we can build, deploy and test end-to-end.
&ndash; GOOS,GbT</p>
</blockquote>

<p>For our SQL language, the thinnest possible query is a select star from a single table with no conditionals. In order to build that, we&rsquo;ll have to start the parser, the semantic model, the transformer that populates the semantic model and the basics of execution.</p>

<p>Our first SQL query to implement is this one:</p>
<pre class="highlight sql"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div></td><td class="code"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">one_to_five</span>
</td></tr></tbody></table></pre>
<p>Through it, we&rsquo;ll build a small part of all the needed pieces of our interpreter.</p>

<p>It&rsquo;s transitions</p>
<pre class="highlight sql"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div></td><td class="code"> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">one_to_five</span>
</td></tr></tbody></table></pre>
<script type="text/graphviz">
digraph wildcard_0 {
  query -> from_table;
  from_table[shape="record"; label="FROM|one_to_five"];
}
</script>

<p>We could build a tree like this, but I&rsquo;m anticipating that we&rsquo;ll likely want to have different behavior for other SELECT args in the future. So, we&rsquo;ll make one that looks more like this:</p>

<script type="text/graphviz">
digraph wildcard_0 {
  query -> from_table;
  query -> args;
  args[shape="record"; label="args|*"];
  from_table[shape="record"; label="FROM|one_to_five"];
}
</script>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div></td><td class="code"><span class="no">SelectQuery</span><span class="nf">.new</span><span class="p">(</span><span class="no">WildCard</span><span class="nf">.new</span><span class="p">,</span> <span class="no">FromTable</span><span class="nf">.new</span><span class="p">(</span><span class="s2">&quot;one_to_five&quot;</span><span class="p">))</span>
</td></tr></tbody></table></pre><pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div></td><td class="code"><span class="o">[</span><span class="p">{</span><span class="s2">&quot;dec&quot;</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">,</span><span class="s2">&quot;eng&quot;</span><span class="o">=&gt;</span><span class="s2">&quot;one&quot;</span><span class="p">},</span>
    <span class="c1">#... </span>
   <span class="o">]</span>
</td></tr></tbody></table></pre>
<h2>First Step of the Skeleton: Acceptance spec.</h2>

<p>Open up <code>spec/sql_awesome_spec.rb</code>.</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div></td><td class="code"><span class="n">describe</span> <span class="no">SQLAwesome</span> <span class="k">do</span>
  <span class="c1"># acceptance specs go here</span>
<span class="k">end</span>
</td></tr></tbody></table></pre>
<p>Here we&rsquo;re going to add our first spec.</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div><div class="lineno">6</div><div class="lineno">7</div><div class="lineno">8</div></td><td class="code"><span class="n">describe</span> <span class="no">SQLAwesome</span> <span class="k">do</span>
  <span class="n">it</span> <span class="s2">&quot;retrieves all columns for all rows with a wildcard&quot;</span> <span class="k">do</span>
    <span class="n">db</span> <span class="o">=</span> <span class="no">SQLAwesome</span><span class="nf">.new_from_csv_dir</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="no">File</span><span class="nf">.dirname</span><span class="p">(</span><span class="kp">__FILE__</span><span class="p">)</span><span class="si">}</span><span class="s2">/../data/&quot;</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">db</span><span class="nf">.eval</span> <span class="s2">&quot;SELECT * FROM one_to_five&quot;</span>
    <span class="n">result</span><span class="nf">.must_equal</span> <span class="n">db</span><span class="o">[</span><span class="s2">&quot;one_to_five&quot;</span><span class="o">]</span>
  <span class="k">end</span>
<span class="k">end</span>
</td></tr></tbody></table></pre>
<p>Some of this I wrote already to simplify things</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div></td><td class="code">    <span class="n">db</span> <span class="o">=</span> <span class="no">SQLAwesome</span><span class="nf">.new_from_csv_dir</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="no">File</span><span class="nf">.dirname</span><span class="p">(</span><span class="kp">__FILE__</span><span class="p">)</span><span class="si">}</span><span class="s2">/../data/&quot;</span>
</td></tr></tbody></table></pre>
<p>builds a <code>RDBMS</code> object with tables populated from the passed directory. It&rsquo;s specs are in <code>spec/rdbms_spec.rb</code> if you&rsquo;re interested.</p>

<p>The neat bit of the spec is</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div></td><td class="code">    <span class="n">result</span> <span class="o">=</span> <span class="n">db</span><span class="nf">.eval</span> <span class="s2">&quot;SELECT * FROM one_to_five&quot;</span>
    <span class="n">result</span><span class="nf">.must_equal</span> <span class="n">db</span><span class="o">[</span><span class="s2">&quot;one_to_five&quot;</span><span class="o">]</span>
</td></tr></tbody></table></pre>
<p>What we&rsquo;re saying here is that evaling our wildcard query is equivalent to looking at the table directly. As in, it&rsquo;s got all the rows and all the columns. Just like if you were to run a <code>*</code> query with no <code>WHERE</code> clause. It&rsquo;s not an amazing test, but it&rsquo;ll serve to build our walking skeleton.</p>

<p>Let&rsquo;s run our specs:</p>
<pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div><div class="lineno">6</div><div class="lineno">7</div><div class="lineno">8</div><div class="lineno">9</div><div class="lineno">10</div><div class="lineno">11</div><div class="lineno">12</div><div class="lineno">13</div><div class="lineno">14</div><div class="lineno">15</div></td><td class="code">$ rake
Run options: --seed 1845

# Running tests:

E.

Finished tests in 0.021476s, 93.1272 tests/s, 139.6908 assertions/s.

  1) Error:
test_0001_retrieves all columns for all rows with a wildcard(SQLAwesome):
NoMethodError: private method `eval&#39; called for #&lt;SQLAwesome::RDBMS:0x007f9ea196c480&gt;
...
2 tests, 3 assertions, 0 failures, 1 errors, 0 skips
rake aborted!
</td></tr></tbody></table></pre>
<p>Oops, I didn&rsquo;t write the <code>eval</code> method for the RDBMS! What should that look like? First, let&rsquo;s back up and talk architecture a little. Our little RDMS is going to need to be able to go through all the stages we talked about earlier. To do that, we&rsquo;ll need to split up some responsibilities.</p>

<script type="text/graphviz">
digraph {
  query_string   -> parser;
  parser         -> tree;
  tree           -> transformer;
  transformer    -> semantic_model;
  semantic_model -> execution;
  parser[shape=rect];
  transformer[shape=rect]
  execution[shape=rect];
}
</script>

<p>Let&rsquo;s drop some code in the RDBMS class to get started.</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div></td><td class="code">  <span class="k">def </span><span class="nf">eval</span> <span class="n">query_string</span>
    <span class="n">intermediate_tree</span> <span class="o">=</span> <span class="no">Parser</span><span class="nf">.new.parse</span> <span class="n">query_string</span>
    <span class="n">model</span> <span class="o">=</span> <span class="no">Transformer</span><span class="nf">.new.apply</span> <span class="n">intermediate_tree</span>
    <span class="n">model</span><span class="nf">.eval</span> <span class="vi">@tables</span>
  <span class="k">end</span>
</td></tr></tbody></table></pre>
<p>I&rsquo;ve already setup classes for the Parser and Transformer in <code>lib/sql_awesome/</code>.</p>

<p>Both of these are using Parslet&rsquo;s parser generator framework classes as superclasses.</p>

<p>Let&rsquo;s see what happens now.</p>
<pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div><div class="lineno">6</div><div class="lineno">7</div><div class="lineno">8</div><div class="lineno">9</div><div class="lineno">10</div><div class="lineno">11</div><div class="lineno">12</div></td><td class="code">$ rake
Run options: --seed 4422

# Running tests:

E.

Finished tests in 0.017203s, 116.2588 tests/s, 174.3882 assertions/s.

  1) Error:
test_0001_retrieves all columns for all rows with a wildcard(SQLAwesome):
NameError: undefined local variable or method `root&#39; for #&lt;SQLAwesome::Parser:0x007f90e4944658&gt;
</td></tr></tbody></table></pre>
<p>That&rsquo;s an interesting error. Let&rsquo;s look at <code>lib/sql_awesome/parser.rb</code></p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div><div class="lineno">6</div><div class="lineno">7</div><div class="lineno">8</div><div class="lineno">9</div><div class="lineno">10</div><div class="lineno">11</div><div class="lineno">12</div><div class="lineno">13</div><div class="lineno">14</div><div class="lineno">15</div><div class="lineno">16</div><div class="lineno">17</div></td><td class="code"><span class="k">module</span> <span class="nn">SQLAwesome</span>
  <span class="c1"># The Parser takes a string and turns it into an intermediate representation.</span>
  <span class="c1"># This representation can be used to populate the Semantic Model.</span>
  <span class="k">class </span><span class="nc">Parser</span> <span class="o">&lt;</span> <span class="no">Parslet</span><span class="o">::</span><span class="no">Parser</span>
    <span class="c1"># root :statement</span>

    <span class="c1"># handy list pattern x.repeat(1,1) &gt; (y &gt;&gt; x).repeat</span>

    <span class="n">rule</span><span class="p">(</span><span class="ss">:ident</span><span class="p">)</span> <span class="p">{</span> <span class="n">match</span><span class="p">(</span><span class="s1">&#39;[a-zA-Z]&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">match</span><span class="p">(</span><span class="s1">&#39;\w&#39;</span><span class="p">)</span><span class="nf">.repeat</span> <span class="p">}</span>
    <span class="n">rule</span><span class="p">(</span><span class="ss">:space</span><span class="p">)</span>  <span class="p">{</span> <span class="n">match</span><span class="p">(</span><span class="s1">&#39;\s&#39;</span><span class="p">)</span><span class="nf">.repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">}</span>
    <span class="n">rule</span><span class="p">(</span><span class="ss">:space?</span><span class="p">)</span> <span class="p">{</span> <span class="n">space</span><span class="nf">.maybe</span> <span class="p">}</span>

    <span class="n">rule</span><span class="p">(</span><span class="ss">:integer</span><span class="p">)</span> <span class="p">{</span> <span class="n">match</span><span class="p">(</span><span class="s1">&#39;[0-9]&#39;</span><span class="p">)</span><span class="nf">.repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="nf">.as</span><span class="p">(</span><span class="ss">:integer</span><span class="p">)</span> <span class="p">}</span>

    <span class="n">rule</span><span class="p">(</span><span class="ss">:comma</span><span class="p">)</span>   <span class="p">{</span> <span class="n">str</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">space?</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</td></tr></tbody></table></pre>
<p>The reason it is complaining is because we need to define a root rule.</p>

<blockquote>
<p>Parslet is an internal DSL for describing PEGs. Parser Expression Grammars. I&rsquo;ve included some handy rules we&rsquo;ll use as building blocks.
It&rsquo;s one of many different tools you can use to write External DSLs.</p>

<p>Regexes are also valid, but SQL is just complicated enough to need a grammar.</p>

<p>You can also use a parser generator that uses an External DSL to define
grammars. For example, <a href="https://github.com/evanphx/kpeg">kpeg</a>.</p>
</blockquote>

<p>Let&rsquo;s try uncommenting <code># root :statement</code> and see what happens.</p>
<pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div><div class="lineno">6</div><div class="lineno">7</div><div class="lineno">8</div><div class="lineno">9</div><div class="lineno">10</div><div class="lineno">11</div><div class="lineno">12</div></td><td class="code">$ rake
Run options: --seed 41503

# Running tests:

E.

Finished tests in 0.016246s, 123.1072 tests/s, 184.6608 assertions/s.

  1) Error:
test_0001_retrieves all columns for all rows with a wildcard(SQLAwesome):
NoMethodError: undefined method `statement&#39; for #&lt;SQLAwesome::Parser:0x007f9ce407c618&gt;
</td></tr></tbody></table></pre>
<p>We haven&rsquo;t defined a rule for statements yet, so it blows up. Before we do that, let&rsquo;s write a test that shows what the input / output for the kind of statement we&rsquo;re building should look like.</p>

<p>Open up <code>spec/parser_spec.rb</code> and we&rsquo;ll write our first parser spec.</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div></td><td class="code"><span class="n">it</span> <span class="s2">&quot;converts a wildcard statement with no where into an intermediate tree&quot;</span> <span class="k">do</span>
  <span class="n">tree</span> <span class="o">=</span> <span class="no">SQLAwesome</span><span class="o">::</span><span class="no">Parser</span><span class="nf">.new.parse</span> <span class="s2">&quot;SELECT * FROM a&quot;</span>
  <span class="n">tree</span><span class="nf">.must_equal</span> <span class="ss">args: </span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="ss">from: </span><span class="s2">&quot;a&quot;</span>
<span class="k">end</span>
</td></tr></tbody></table></pre>
<p>Remember the tree diagram from before?</p>

<p><code>Tree Diagram goes here</code></p>

<blockquote>
<p>do we want parsing to be case-insensitive wrt keywords?</p>
</blockquote>

<p>Now we have a new failing test</p>
<pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div></td><td class="code">  2) Error:
test_0001_converts a wildcard statement with no where into an intermediate tree(SQLAwesome::Parser):
NoMethodError: undefined method `statement&#39; for #&lt;SQLAwesome::Parser:0x007f83cb089c00&gt;
</td></tr></tbody></table></pre>
<p>Let&rsquo;s make that one pass. In parser.rb, add this rule:</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div></td><td class="code"><span class="n">rule</span><span class="p">(</span><span class="ss">:statement</span><span class="p">)</span> <span class="p">{</span> <span class="n">str</span><span class="p">(</span><span class="s2">&quot;SELECT&quot;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">space?</span> <span class="o">&gt;&gt;</span>
                   <span class="n">str</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">)</span><span class="nf">.as</span><span class="p">(</span><span class="ss">:args</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">space?</span> <span class="o">&gt;&gt;</span>
                   <span class="n">str</span><span class="p">(</span><span class="s2">&quot;FROM&quot;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">space?</span> <span class="o">&gt;&gt;</span> <span class="n">ident</span><span class="nf">.as</span><span class="p">(</span><span class="ss">:from</span><span class="p">)</span>
                 <span class="p">}</span>
</td></tr></tbody></table></pre>
<p>That probably looks a little complicated, so let&rsquo;s break it down a little.</p>

<p>Parslet parsers are defined in terms of rules. You define a new rule by calling <code>rule</code> with a name and a block containing the grammar snippet that it matches. Rules are available in blocks as instance variables, which makes it easy to refer to them from other rules.</p>

<p>What this rule is doing is:</p>

<ol>
<li><code>str(&quot;SELECT&quot;)</code> looking for the string <code>SELECT</code></li>
<li><code>&gt;&gt; space?</code> This refers to the <code>space?</code> rule that was already written. It matches space characters or nothing.</li>
<li><p><code>str(&quot;*&quot;)</code> looks for the string <code>*</code></p>

<p>Parslet provides a number of small parsers or parslets that you combine to build a full parser. For example <code>str</code> is a helper method that actually creates an instance of a class that only recognizes strings.</p></li>
</ol>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div></td><td class="code"><span class="k">def </span><span class="nf">str</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
  <span class="no">Atoms</span><span class="o">::</span><span class="no">Str</span><span class="nf">.new</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
<span class="k">end</span>
</td></tr></tbody></table></pre>
<p><a href="https://github.com/kschiess/parslet/blob/142f33bb147edede1753de7fc0ea066e07f565fb/lib/parslet.rb#L155-L157">str impl</a></p>

<p>Parslet isn&rsquo;t the only way to build grammars for external DSLs in Ruby. It&rsquo;s just nice because as an internal DSL it doesn&rsquo;t have a separate compile step.</p>

<p>After adding the new code, the parser test is passing, and we&rsquo;re back to having a failing acceptance test. But, the error has changed.</p>
<pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div></td><td class="code">  1) Error:
test_0001_retrieves all columns for all rows with a wildcard(SQLAwesome):
NoMethodError: private method `eval&#39; called for {:args=&gt;&quot;*&quot;@7, :from=&gt;&quot;one_to_five&quot;@14}:Hash
    sql_workshop/lib/sql_awesome/rdbms.rb:13:in `eval&#39;
</td></tr></tbody></table></pre>
<p>What&rsquo;s going on here? Let&rsquo;s look back at <code>eval</code></p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div></td><td class="code">    <span class="k">def </span><span class="nf">eval</span> <span class="n">query_string</span>
      <span class="n">intermediate_tree</span> <span class="o">=</span> <span class="no">Parser</span><span class="nf">.new.parse</span> <span class="n">query_string</span>
      <span class="n">model</span> <span class="o">=</span> <span class="no">Transformer</span><span class="nf">.new.apply</span> <span class="n">intermediate_tree</span>
      <span class="n">model</span><span class="nf">.eval</span> <span class="vi">@tables</span> <span class="c1"># line 13</span>
    <span class="k">end</span>
</td></tr></tbody></table></pre>
<p>The problem is our <code>Transformer</code> isn&rsquo;t transforming anything! If you look in <code>lib/sql_awesome/transformer.rb</code>, you&rsquo;ll see it doesn&rsquo;t have much in it yet.</p>

<p>Parslet&rsquo;s transform framework helps you to convert the intermediate data structure created by it&rsquo;s parser into something more useful. In our case, we&rsquo;re going to use it to populate our semantic model of a SQL query.</p>

<p>It shares a similar interface with the parser&rsquo;s DSL, but instead of naming things on the left and describing what they match on the right, it describes what to match on the left and what to do with it on the right.</p>

<p>For our current tree, we only need one rule to transform into the right model classes&ndash;but before we do that, let&rsquo;s write a test.</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div><div class="lineno">6</div></td><td class="code"><span class="n">it</span> <span class="s2">&quot;converts {args:&#39;*&#39;, from:&#39;a&#39;} into a wild card query object&quot;</span> <span class="k">do</span>
  <span class="n">result</span> <span class="o">=</span> <span class="no">SQLAwesome</span><span class="o">::</span><span class="no">Transformer</span><span class="nf">.new.apply</span> <span class="n">args</span><span class="ss">:&#39;*&#39;</span><span class="p">,</span>
                                             <span class="n">from</span><span class="ss">:&#39;a&#39;</span>

  <span class="n">result</span><span class="nf">.inspect.must_equal</span> <span class="s2">&quot;Query: Fields:all FromTable:a&quot;</span>
<span class="k">end</span>
</td></tr></tbody></table></pre>
<p>This is probably not the best test we could write, but again, the point of the walking skeleton is to get all the pieces in place for building out more things. We can clean it up later if it comes to that.</p>

<p>Let&rsquo;s run tests again:</p>
<pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div><div class="lineno">6</div><div class="lineno">7</div></td><td class="code">  2) Failure:
test_0001_converts {args:&#39;*&#39;, from:&#39;a&#39;} into a wild card query object(SQLAwesome::Transformer) [sql_workshop/spec/transformer_spec.rb:8]:
--- expected
+++ actual
@@ -1 +1 @@
-&quot;Query: Fields:all FromTable:a&quot;
+&quot;{:args=&gt;\&quot;*\&quot;, :from=&gt;\&quot;a\&quot;}&quot;
</td></tr></tbody></table></pre>
<p>Sweet! A new failure! Since a transform with no rules does nothing, the resulting object is currently the input. Let&rsquo;s change that.</p>

<p>Here&rsquo;s the implementation:</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div><div class="lineno">6</div></td><td class="code">    <span class="n">rule</span><span class="p">(</span><span class="ss">args: </span><span class="n">simple</span><span class="p">(</span><span class="ss">:args</span><span class="p">),</span>
         <span class="ss">from: </span><span class="n">simple</span><span class="p">(</span><span class="ss">:table_name</span><span class="p">))</span> <span class="p">{</span> 
           <span class="no">SemanticModel</span><span class="o">::</span><span class="no">SelectQuery</span><span class="nf">.new</span><span class="p">(</span>
             <span class="no">SemanticModel</span><span class="o">::</span><span class="no">WildCard</span><span class="nf">.new</span><span class="p">,</span>
             <span class="n">table_name</span><span class="p">)</span>
         <span class="p">}</span>
</td></tr></tbody></table></pre>
<p>Put this inside <code>lib/sql_awesome/transformer.rb</code> next to / replacing the commented out rules.</p>

<p>What does it do? Like I said above, Parslet&rsquo;s transforms work as pattern matchers. Our pattern is</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div></td><td class="code"><span class="p">{</span>        <span class="ss">args: </span><span class="n">simple</span><span class="p">(</span><span class="ss">:args</span><span class="p">),</span>
         <span class="ss">from: </span><span class="n">simple</span><span class="p">(</span><span class="ss">:table_name</span><span class="p">)}</span>
</td></tr></tbody></table></pre>
<p>Which tells parslet to look for hashes inside the intermediate tree that have the keys <code>:args</code> and <code>:from</code> whose values are <code>simple</code>. When it finds a matching hash, it calls the block and replaces the matched portion of the tree with the result. While it&rsquo;s matching, it walks the tree leaves up, so each subtree is completed before going to it&rsquo;s parent. This lets you do some neat stuff, for example you could potentially write a calculator language that does all it&rsquo;s calculating in the transformer.</p>

<p>Values are <code>simple</code> if they are not arrays or hashes. So in our code, <code>args: simple(:args)</code> will match a hash that has the key args whose value is not an array or hash, eg <code>{args: &quot;*&quot;}</code>. It also matches things that are not strings, so something like <code>{args: WildCard.new}</code> would also work. Keep that in mind for later.</p>

<p>Let&rsquo;s run tests again.</p>
<pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div></td><td class="code">  2) Error:
test_0001_converts {args:&#39;*&#39;, from:&#39;a&#39;} into a wild card query object(SQLAwesome::Transformer):
NameError: uninitialized constant SQLAwesome::SemanticModel::SelectQuery
    sql_workshop/lib/sql_awesome/transformer.rb:5:in `block in &lt;class:Transformer&gt;&#39;
</td></tr></tbody></table></pre>
<p>Our semantic model classes don&rsquo;t exist yet! What should we do? Write more tests of course. To start, we&rsquo;ll just write enough to make the Transformer happy.</p>

<p>In <code>spec/semantic_model_spec.rb</code></p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div><div class="lineno">6</div></td><td class="code"><span class="n">describe</span> <span class="no">SelectQuery</span> <span class="k">do</span>
  <span class="n">it</span> <span class="s2">&quot;has a nice inspect format&quot;</span> <span class="k">do</span>
    <span class="n">query</span> <span class="o">=</span> <span class="no">SelectQuery</span><span class="nf">.new</span> <span class="s2">&quot;args&quot;</span><span class="p">,</span> <span class="s2">&quot;table&quot;</span>
    <span class="n">query</span><span class="nf">.inspect.must_equal</span> <span class="s2">&quot;Query: </span><span class="se">\&quot;</span><span class="s2">args</span><span class="se">\&quot;</span><span class="s2"> FromTable:table&quot;</span>
  <span class="k">end</span>
<span class="k">end</span>
</td></tr></tbody></table></pre><pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div></td><td class="code">$ rake
sql_workshop/spec/semantic_model_spec.rb:6:in `block in &lt;top (required)&gt;&#39;: uninitialized constant SelectQuery (NameError)
</td></tr></tbody></table></pre>
<p>Missing constant? Easily done.</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div><div class="lineno">6</div></td><td class="code"><span class="k">module</span> <span class="nn">SQLAwesome</span>
  <span class="k">module</span> <span class="nn">SemanticModel</span>
    <span class="k">class </span><span class="nc">SelectQuery</span> <span class="o">&lt;</span> <span class="no">Struct</span><span class="nf">.new</span><span class="p">(</span><span class="ss">:args</span><span class="p">,</span> <span class="ss">:from_table</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</td></tr></tbody></table></pre><pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div><div class="lineno">6</div><div class="lineno">7</div></td><td class="code">  2) Failure:
test_0001_has a nice inspect format(SQLAwesome::SemanticModel::SQLAwesome::SemanticModel::SelectQuery) [sql_workshop/spec/semantic_model_spec.rb:9]:
--- expected
+++ actual
@@ -1 +1 @@
-&quot;Query: \&quot;args\&quot; FromTable:table&quot;
+&quot;#&lt;struct SQLAwesome::SemanticModel::SelectQuery args=\&quot;args\&quot;, from_table=\&quot;table\&quot;&gt;&quot;
</td></tr></tbody></table></pre>
<p>Let&rsquo;s add a better <code>inspect</code>.</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div></td><td class="code">  <span class="k">def </span><span class="nf">inspect</span>
    <span class="s2">&quot;Query: </span><span class="si">#{</span><span class="n">args</span><span class="nf">.inspect</span><span class="si">}</span><span class="s2"> FromTable:</span><span class="si">#{</span><span class="n">from_table</span><span class="si">}</span><span class="s2">&quot;</span>
  <span class="k">end</span>
</td></tr></tbody></table></pre>
<p>Bam! now that test passes. But the transformer is still unhappy:</p>
<pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div></td><td class="code">  2) Error:
test_0001_converts {args:&#39;*&#39;, from:&#39;a&#39;} into a wild card query object(SQLAwesome::Transformer):
NameError: uninitialized constant SQLAwesome::SemanticModel::WildCard
</td></tr></tbody></table></pre>
<p>Let&rsquo;s add it, but first a test.</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div></td><td class="code">  <span class="n">describe</span> <span class="no">WildCard</span> <span class="k">do</span>
    <span class="n">it</span> <span class="s2">&quot;has an inspect that says it shows all fields&quot;</span> <span class="k">do</span>
      <span class="no">WildCard</span><span class="nf">.new.inspect.must_equal</span> <span class="s2">&quot;Fields:all&quot;</span>
    <span class="k">end</span>
  <span class="k">end</span>
</td></tr></tbody></table></pre>
<p>Failure on const after running <code>rake</code>:</p>
<pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div></td><td class="code">sql_workshop/spec/semantic_model_spec.rb:12:in `block in &lt;top (required)&gt;&#39;: uninitialized constant WildCard (NameError)
</td></tr></tbody></table></pre>
<p>Fix it in <code>lib/sql_awesome/semantic_model.rb</code>:</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div></td><td class="code"><span class="k">class </span><span class="nc">WildCard</span>
<span class="k">end</span>
</td></tr></tbody></table></pre>
<p>Now it&rsquo;s failing properly:</p>
<pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div><div class="lineno">6</div><div class="lineno">7</div></td><td class="code">  2) Failure:
test_0001_has an inspect that says it shows all fields(SQLAwesome::SemanticModel::SQLAwesome::SemanticModel::WildCard) [sql_workshop/spec/semantic_model_spec.rb:14]:
--- expected
+++ actual
@@ -1 +1 @@
-&quot;Fields:all&quot;
+&quot;#&lt;SQLAwesome::SemanticModel::WildCard:0xXXXXXX&gt;&quot;
</td></tr></tbody></table></pre>
<p>Let&rsquo;s fix that now with</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div></td><td class="code">  <span class="k">def </span><span class="nf">inspect</span>
    <span class="s2">&quot;Fields:all&quot;</span>
  <span class="k">end</span>
</td></tr></tbody></table></pre>
<p>And we&rsquo;re back to one failing test, our acceptance test.</p>
<pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div></td><td class="code">  1) Error:
test_0001_retrieves all columns for all rows with a wildcard(SQLAwesome):
NoMethodError: private method `eval&#39; called for Query: Fields:all FromTable:one_to_five:SQLAwesome::SemanticModel::SelectQuery
    sql_workshop/lib/sql_awesome/rdbms.rb:13:in `eval&#39;
</td></tr></tbody></table></pre>
<p>Now the problem is that we are calling eval on a SelectQuery object. Isn&rsquo;t that cool. It looks like all that&rsquo;s left is to add tests, and a method.</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div></td><td class="code">  <span class="n">it</span> <span class="s2">&quot;gives you back all the things in the table when args is a wild card&quot;</span> <span class="k">do</span>
    <span class="n">query</span> <span class="o">=</span> <span class="no">SelectQuery</span><span class="nf">.new</span> <span class="no">WildCard</span><span class="nf">.new</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">query</span><span class="nf">.eval</span> <span class="s2">&quot;a&quot;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">}</span><span class="o">]</span>
    <span class="n">result</span><span class="nf">.must_equal</span> <span class="o">[</span><span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">}</span><span class="o">]</span>
  <span class="k">end</span>
</td></tr></tbody></table></pre>
<p>Tests fail, as expected.</p>
<pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div></td><td class="code">  2) Error:
test_0002_gives you back all the things in the table when args is a wild card(SQLAwesome::SemanticModel::SQLAwesome::SemanticModel::SelectQuery):
NoMethodError: private method `eval&#39; called for Query: Fields:all FromTable:a:SQLAwesome::SemanticModel::SelectQuery
</td></tr></tbody></table></pre>
<p>Add the missing method:</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div></td><td class="code"><span class="k">def </span><span class="nf">eval</span> <span class="n">database</span>
<span class="k">end</span>
</td></tr></tbody></table></pre><pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div></td><td class="code">  2) Failure:
test_0002_gives you back all the things in the table when args is a wild card(SQLAwesome::SemanticModel::SQLAwesome::SemanticModel::SelectQuery) [sql_workshop/spec/semantic_model_spec.rb:15]:
Expected: [{&quot;x&quot;=&gt;1}]
  Actual: nil
</td></tr></tbody></table></pre>
<p>What should a SelectQuery do in this case? Well the simplest thing that could possibly work is to just look up the table.</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div></td><td class="code">  <span class="n">database</span><span class="o">[</span><span class="n">from_table</span><span class="o">]</span>
</td></tr></tbody></table></pre>
<p>Now everything should be passing, but the acceptance test isn&rsquo;t. Why is that? If we took the time to put debug print statements in RDBMS.eval, what you&rsquo;d see is that we are looking up the right table and the table is in the <code>@tables</code> hash. What gives?</p>

<p>This is a Parslet being a little tricky problem. Parslet, when it tokenizes, doesn&rsquo;t give you strings, it gives you <code>Slice</code>s, which means that when you try to use them as hash keys, weird things can happen(I bet there&rsquo;s a way to fix it, but I digress).</p>

<p>For now, the easiest way to ensure it works is to call <code>to_s</code> on the strings in the transformer.</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div></td><td class="code"><span class="no">SemanticModel</span><span class="o">::</span><span class="no">SelectQuery</span><span class="nf">.new</span><span class="p">(</span><span class="no">SemanticModel</span><span class="o">::</span><span class="no">WildCard</span><span class="nf">.new</span><span class="p">,</span> <span class="n">table_name</span><span class="nf">.to_s</span><span class="p">)</span>
</td></tr></tbody></table></pre><pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div><div class="lineno">6</div><div class="lineno">7</div><div class="lineno">8</div><div class="lineno">9</div><div class="lineno">10</div></td><td class="code">$ rake
Run options: --seed 17061

# Running tests:

.......

Finished tests in 0.021596s, 324.1341 tests/s, 416.7438 assertions/s.

7 tests, 9 assertions, 0 failures, 0 errors, 0 skips
</td></tr></tbody></table></pre>
<p>Now everything&rsquo;s passing and we&rsquo;ve got our walking skeleton. The walking skeleton was the trickiest bit because we didn&rsquo;t have any structure in place yet. Now that it&rsquo;s done things should go more easily.</p>

<p>Next we&rsquo;ll start looking at filtering what fields we want to get out.</p>

<h1>Selecting a Single Field</h1>

<p>The next feature we&rsquo;re planning on supporting is allowing users to specify what fields they want to pull out of a table.</p>
<pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div></td><td class="code">SELECT eng FROM one_to_five
</td></tr></tbody></table></pre>
<p>For this one we&rsquo;re going to modify our tree to make it able to represent both wild card and single field arguments. To do this we&rsquo;ll change the <code>args</code> subtree to let it support different types of things below it.</p>

<ol>
<li><code>SELECT eng FROM one_to_five</code>
1.</li>
</ol>

<script type="text/graphviz">
digraph one_column {
  query -> from_table;
  query -> args;
  args -> field;
  field[shape="record"; label="field|eng"];
  from_table[shape="record"; label="FROM|one_to_five"]
}
</script>

<ol>
<li><p><code>SelectQuery.new(Field.new(&quot;eng&quot;), FromTable.new(&quot;one_to_five&quot;))</code></p></li>
<li></li>
</ol>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div></td><td class="code"><span class="o">[</span><span class="p">{</span><span class="s2">&quot;eng&quot;</span><span class="o">=&gt;</span><span class="s2">&quot;one&quot;</span><span class="p">},</span>
    <span class="c1">#... </span>
   <span class="o">]</span>
</td></tr></tbody></table></pre>
<p>First, we&rsquo;ll put together the acceptance test.</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div><div class="lineno">6</div><div class="lineno">7</div><div class="lineno">8</div><div class="lineno">9</div><div class="lineno">10</div><div class="lineno">11</div><div class="lineno">12</div></td><td class="code">  <span class="n">it</span> <span class="s2">&quot;retrieves one column for all rows when only that column is specified&quot;</span> <span class="k">do</span>
    <span class="n">db</span> <span class="o">=</span> <span class="no">SQLAwesome</span><span class="nf">.new_from_csv_dir</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="no">File</span><span class="nf">.dirname</span><span class="p">(</span><span class="kp">__FILE__</span><span class="p">)</span><span class="si">}</span><span class="s2">/../data/&quot;</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">db</span><span class="nf">.eval</span> <span class="s2">&quot;SELECT eng FROM one_to_five&quot;</span>
    <span class="n">result</span><span class="nf">.must_equal</span> <span class="o">[</span>
       <span class="p">{</span><span class="s2">&quot;eng&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;one&quot;</span><span class="p">},</span>
       <span class="p">{</span><span class="s2">&quot;eng&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;two&quot;</span><span class="p">},</span>
       <span class="p">{</span><span class="s2">&quot;eng&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;three&quot;</span><span class="p">},</span>
       <span class="p">{</span><span class="s2">&quot;eng&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;four&quot;</span><span class="p">},</span>
       <span class="p">{</span><span class="s2">&quot;eng&quot;</span> <span class="o">=&gt;</span> <span class="s2">&quot;five&quot;</span><span class="p">}</span>
    <span class="o">]</span>
  <span class="k">end</span>
</td></tr></tbody></table></pre>
<p>Let&rsquo;s see what that gets us</p>
<pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div><div class="lineno">6</div><div class="lineno">7</div><div class="lineno">8</div><div class="lineno">9</div><div class="lineno">10</div><div class="lineno">11</div><div class="lineno">12</div></td><td class="code">$ rake
Run options: --seed 42840

# Running tests:

.E......

Finished tests in 0.021725s, 368.2394 tests/s, 414.2693 assertions/s.

  1) Error:
test_0002_retrieves one column for all rows when only that column is specified(SQLAwesome):
Parslet::ParseFailed: Failed to match sequence (&#39;SELECT&#39; SPACE? args:&#39;*&#39; SPACE? &#39;FROM&#39; SPACE? from:IDENT) at line 1 char 8.
</td></tr></tbody></table></pre>
<p>Failed to parse. As expected, since our current parser only works for <code>SELECT * FROM _</code> queries. That message is kind of ugly, we should fix it, but right now let&rsquo;s focus on getting selecting a column working.</p>

<blockquote>
<p>TODO
* customize parse error handling to be nicer</p>
</blockquote>

<p>Let&rsquo;s begin with changing the existing wildcard parser test to reflect our different tree.</p>

<script type="text/graphviz">
digraph one_column {
  query -> from_table;
  query -> args;
  args -> field;
  field[shape="record"; label="wildcard|*"];
  from_table[shape="record"; label="FROM|one_to_five"];
}
</script>

<p>We could leave it and create a new grammar rule that&rsquo;s separate, but I don&rsquo;t think it&rsquo;s as neat.</p>

<p>So our old test becomes:</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div></td><td class="code">  <span class="n">it</span> <span class="s2">&quot;converts a wildcard statement with no where into an intermediate tree&quot;</span> <span class="k">do</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="no">SQLAwesome</span><span class="o">::</span><span class="no">Parser</span><span class="nf">.new.parse</span> <span class="s2">&quot;SELECT * FROM a&quot;</span>
    <span class="n">tree</span><span class="nf">.must_equal</span> <span class="ss">args: </span><span class="p">{</span><span class="ss">wildcard: </span><span class="s2">&quot;*&quot;</span><span class="p">},</span> <span class="ss">from: </span><span class="s2">&quot;a&quot;</span>
  <span class="k">end</span>
</td></tr></tbody></table></pre>
<p>Which fails understandably.</p>
<pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div><div class="lineno">6</div><div class="lineno">7</div></td><td class="code">  2) Failure:
test_0001_converts a wildcard statement with no where into an intermediate tree(SQLAwesome::Parser) [sql_workshop/spec/parser_spec.rb:7]:
--- expected
+++ actual
@@ -1 +1 @@
-{:args=&gt;{:wildcard=&gt;&quot;*&quot;}, :from=&gt;&quot;a&quot;}
+{:args=&gt;&quot;*&quot;@7, :from=&gt;&quot;a&quot;@14}
</td></tr></tbody></table></pre>
<p>We update the parser&rsquo;s rules.</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div></td><td class="code">    <span class="n">rule</span><span class="p">(</span><span class="ss">:statement</span><span class="p">)</span> <span class="p">{</span> <span class="n">str</span><span class="p">(</span><span class="s2">&quot;SELECT&quot;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">space?</span> <span class="o">&gt;&gt;</span>
                       <span class="n">args</span><span class="nf">.as</span><span class="p">(</span><span class="ss">:args</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">space?</span> <span class="o">&gt;&gt;</span>
                       <span class="n">str</span><span class="p">(</span><span class="s2">&quot;FROM&quot;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">space?</span> <span class="o">&gt;&gt;</span> <span class="n">ident</span><span class="nf">.as</span><span class="p">(</span><span class="ss">:from</span><span class="p">)</span>
                     <span class="p">}</span>
    <span class="n">rule</span><span class="p">(</span><span class="ss">:args</span><span class="p">)</span> <span class="p">{</span> <span class="n">str</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">)</span><span class="nf">.as</span><span class="p">(</span><span class="ss">:wildcard</span><span class="p">)}</span>
</td></tr></tbody></table></pre>
<p>What I&rsquo;m doing here is expanding the grammar to treat args as it&rsquo;s own rule. Right now it&rsquo;s kind of boring, just a wildcard, but it gives us a place to change the grammar.</p>

<p>That causes the parser tests to pass, but breaks our previous integration test, because the transformer doesn&rsquo;t know about the new structure. Let&rsquo;s fix it.</p>

<p>Test first:</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div></td><td class="code">  <span class="n">it</span> <span class="s2">&quot;converts {args:{wildcard:&#39;*&#39;}, from:&#39;a&#39;} into a wild card query object&quot;</span> <span class="k">do</span>
    <span class="n">result</span> <span class="o">=</span> <span class="no">SQLAwesome</span><span class="o">::</span><span class="no">Transformer</span><span class="nf">.new.apply</span> <span class="ss">args: </span><span class="p">{</span><span class="n">wildcard</span><span class="ss">:&#39;*&#39;</span><span class="p">},</span> <span class="n">from</span><span class="ss">:&#39;a&#39;</span>

    <span class="n">result</span><span class="nf">.inspect.must_equal</span> <span class="s2">&quot;Query: Fields:all FromTable:a&quot;</span>
  <span class="k">end</span>
</td></tr></tbody></table></pre>
<p>Expected Failure:</p>
<pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div><div class="lineno">6</div><div class="lineno">7</div></td><td class="code">  3) Failure:
test_0001_converts {args:&#39;*&#39;, from:&#39;a&#39;} into a wild card query object(SQLAwesome::Transformer) [sql_workshop/spec/transformer_spec.rb:8]:
--- expected
+++ actual
@@ -1 +1 @@
-&quot;Query: Fields:all FromTable:a&quot;
+&quot;{:args=&gt;{:wildcard=&gt;\&quot;*\&quot;}, :from=&gt;\&quot;a\&quot;}&quot;
</td></tr></tbody></table></pre>
<p>Now for the implementation. Here we&rsquo;re creating a new rule specifically for wildcards. This will make it easy to drop in the field support next.</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div></td><td class="code"><span class="n">rule</span><span class="p">(</span><span class="ss">args: </span><span class="n">simple</span><span class="p">(</span><span class="ss">:args</span><span class="p">),</span>
     <span class="ss">from: </span><span class="n">simple</span><span class="p">(</span><span class="ss">:table_name</span><span class="p">))</span> <span class="p">{</span> 
       <span class="no">SemanticModel</span><span class="o">::</span><span class="no">SelectQuery</span><span class="nf">.new</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">table_name</span><span class="nf">.to_s</span><span class="p">)</span>
     <span class="p">}</span>
<span class="n">rule</span><span class="p">(</span><span class="ss">wildcard: </span><span class="n">simple</span><span class="p">(</span><span class="ss">:asterisk</span><span class="p">))</span> <span class="p">{</span> <span class="no">SemanticModel</span><span class="o">::</span><span class="no">WildCard</span><span class="nf">.new</span> <span class="p">}</span>
</td></tr></tbody></table></pre>
<p>Now we&rsquo;re back to one failing test. It&rsquo;s the one we&rsquo;re working on. I&rsquo;d call that a good refactor.</p>

<p>Let&rsquo;s add a new parser test for the one field case.</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div></td><td class="code">  <span class="n">it</span> <span class="s2">&quot;converts a one field statement with no where into an intermediate tree&quot;</span> <span class="k">do</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="no">SQLAwesome</span><span class="o">::</span><span class="no">Parser</span><span class="nf">.new.parse</span> <span class="s2">&quot;SELECT b FROM a&quot;</span>
    <span class="n">tree</span><span class="nf">.must_equal</span> <span class="ss">args: </span><span class="p">{</span><span class="ss">field: </span><span class="s2">&quot;b&quot;</span><span class="p">},</span> <span class="ss">from: </span><span class="s2">&quot;a&quot;</span>
  <span class="k">end</span>
</td></tr></tbody></table></pre>
<p>Run tests and we see our good old parse error. But, now there&rsquo;s an simple place to drop in support.</p>

<p>All we have to do is add an OR to the new <code>args</code> rule we extracted in the last step.</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div></td><td class="code">    <span class="n">rule</span><span class="p">(</span><span class="ss">:args</span><span class="p">)</span> <span class="p">{</span> <span class="n">ident</span><span class="nf">.as</span><span class="p">(</span><span class="ss">:field</span><span class="p">)</span> <span class="o">|</span> <span class="n">str</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">)</span><span class="nf">.as</span><span class="p">(</span><span class="ss">:wildcard</span><span class="p">)}</span>
</td></tr></tbody></table></pre>
<p>In parslet, the <code>|</code> operator is overridden to construct a parser that accepts either the right side or left side. Here we make the args rule accept either an ident, in which case we call it field, or an asterisk, in which case we call it wildcard.</p>

<p>And, bam! Our error message changed, as expected, in the same way it did for the first task.</p>
<pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div></td><td class="code">  1) Error:
test_0002_retrieves one column for all rows when only that column is specified(SQLAwesome):
NoMethodError: private method `eval&#39; called for {:args=&gt;{:field=&gt;&quot;eng&quot;@7}, :from=&gt;&quot;one_to_five&quot;@16}:Hash
</td></tr></tbody></table></pre>
<p>This means that the transformer didn&rsquo;t do it&rsquo;s job because it couldn&rsquo;t recognize the new intermediate tree.</p>

<p>So, let&rsquo;s fix that up.
Test:</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div></td><td class="code">  <span class="n">it</span> <span class="s2">&quot;converts {args:{field:&#39;b&#39;}, from:&#39;a&#39;} into a single field query object&quot;</span> <span class="k">do</span>
    <span class="n">result</span> <span class="o">=</span> <span class="no">SQLAwesome</span><span class="o">::</span><span class="no">Transformer</span><span class="nf">.new.apply</span> <span class="ss">args: </span><span class="p">{</span><span class="n">field</span><span class="ss">:&#39;b&#39;</span><span class="p">},</span> <span class="n">from</span><span class="ss">:&#39;a&#39;</span>

    <span class="n">result</span><span class="nf">.inspect.must_equal</span> <span class="s2">&quot;Query: Fields:[b] FromTable:a&quot;</span>
  <span class="k">end</span>
</td></tr></tbody></table></pre><pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div><div class="lineno">6</div><div class="lineno">7</div></td><td class="code">  2) Failure:
test_0002_converts {args:{field:&#39;b&#39;}, from:&#39;a&#39;} into a single field query object(SQLAwesome::Transformer) [sql_workshop/spec/transformer_spec.rb:14]:
--- expected
+++ actual
@@ -1 +1 @@
-&quot;Query: Fields:[b] FromTable:a&quot;
+&quot;{:args=&gt;{:field=&gt;\&quot;b\&quot;}, :from=&gt;\&quot;a\&quot;}&quot;
</td></tr></tbody></table></pre>
<p>Implementation</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div></td><td class="code"><span class="n">rule</span><span class="p">(</span><span class="ss">field: </span><span class="n">simple</span><span class="p">(</span><span class="ss">:field_name</span><span class="p">))</span> <span class="p">{</span> <span class="no">SemanticModel</span><span class="o">::</span><span class="no">Field</span><span class="nf">.new</span> <span class="n">field_name</span><span class="nf">.to_s</span> <span class="p">}</span>
</td></tr></tbody></table></pre>
<p>It works the same as the wildcard transformation, only we want to pass that into the object we are constructing. And this time, we&rsquo;ll remember to <code>to_s</code> it.</p>

<blockquote>
<p>There may be times when you want to delay <code>to_s</code> when using parslet because you can use the Slice&rsquo;s metadata to your advantage when reporting errors.</p>
</blockquote>

<p>That gets us our familiar const error.</p>
<pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div></td><td class="code">  2) Error:
test_0002_converts {args:{field:&#39;b&#39;}, from:&#39;a&#39;} into a single field query object(SQLAwesome::Transformer):
NameError: uninitialized constant SQLAwesome::SemanticModel::Field
</td></tr></tbody></table></pre>
<p>So, we go and start a new <code>describe</code> block in the <code>semantic_model_spec.rb</code></p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div><div class="lineno">6</div></td><td class="code"><span class="n">describe</span> <span class="no">Field</span> <span class="k">do</span>
  <span class="n">it</span> <span class="s2">&quot;has an inspect method that shows its field&quot;</span> <span class="k">do</span>
    <span class="n">field</span> <span class="o">=</span> <span class="no">Field</span><span class="nf">.new</span> <span class="s2">&quot;myfield&quot;</span>
    <span class="n">field</span><span class="nf">.inspect.must_equal</span> <span class="s2">&quot;Fields:[myfield]&quot;</span>
  <span class="k">end</span>
<span class="k">end</span>
</td></tr></tbody></table></pre>
<p>Then we go through the constant not found, define class, inspect uses default, redefine it dance to end up at this implementation.</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div></td><td class="code"><span class="k">class </span><span class="nc">Field</span> <span class="o">&lt;</span> <span class="no">Struct</span><span class="nf">.new</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span>
  <span class="k">def </span><span class="nf">inspect</span>
    <span class="s2">&quot;Fields:[</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">]&quot;</span>
  <span class="k">end</span>
<span class="k">end</span>
</td></tr></tbody></table></pre>
<p>And now we&rsquo;re back to the acceptance test, but with a new and interesting error.</p>
<pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div><div class="lineno">6</div><div class="lineno">7</div></td><td class="code">  1) Failure:
test_0002_retrieves one column for all rows when only that column is specified(SQLAwesome) [sql_workshop/spec/sql_awesome_spec.rb:16]:
--- expected
+++ actual
@@ -1 +1 @@
-[{&quot;eng&quot;=&gt;&quot;one&quot;}, {&quot;eng&quot;=&gt;&quot;two&quot;}, {&quot;eng&quot;=&gt;&quot;three&quot;}, {&quot;eng&quot;=&gt;&quot;four&quot;}, {&quot;eng&quot;=&gt;&quot;five&quot;}]
+[#&lt;CSV::Row &quot;dec&quot;:&quot;1&quot; &quot;eng&quot;:&quot;one&quot;&gt;, #&lt;CSV::Row &quot;dec&quot;:&quot;2&quot; &quot;eng&quot;:&quot;two&quot;&gt;, #&lt;CSV::Row &quot;dec&quot;:&quot;3&quot; &quot;eng&quot;:&quot;three&quot;&gt;, #&lt;CSV::Row &quot;dec&quot;:&quot;4&quot; &quot;eng&quot;:&quot;four&quot;&gt;, #&lt;CSV::Row &quot;dec&quot;:&quot;5&quot; &quot;eng&quot;:&quot;five&quot;&gt;]
</td></tr></tbody></table></pre>
<p>Back when we implemented the wildcard before, we just passed the table&rsquo;s values through without filter. But, what we really want is to have the SELECT&rsquo;s args determine what is passed through from each row. Let&rsquo;s change that for SelectQuery and WildCard, and then go back and finish this out.</p>

<p>SelectQuery doesn&rsquo;t need any test changes to support this, but currently WildCard has no notion about it, so let&rsquo;s write a test.</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div><div class="lineno">6</div><div class="lineno">7</div><div class="lineno">8</div></td><td class="code">  <span class="n">describe</span> <span class="no">WildCard</span> <span class="k">do</span>
    <span class="c1"># ...</span>
    <span class="n">it</span> <span class="s2">&quot;passes back the row as is when asked to filter&quot;</span> <span class="k">do</span>
      <span class="n">wildcard</span> <span class="o">=</span> <span class="no">WildCard</span><span class="nf">.new</span>
      <span class="n">original</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">,</span><span class="s2">&quot;b&quot;</span><span class="o">=&gt;</span><span class="mi">2</span><span class="p">}</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">wildcard</span><span class="nf">.filter</span> <span class="n">original</span>
      <span class="n">result</span><span class="nf">.must_equal</span> <span class="n">original</span>
    <span class="k">end</span>
</td></tr></tbody></table></pre>
<p>This results in a <code>NoMethodError</code> as expected. Let&rsquo;s implement it.</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div></td><td class="code">  <span class="k">def </span><span class="nf">filter</span> <span class="n">row</span>
    <span class="n">row</span>
  <span class="k">end</span>
</td></tr></tbody></table></pre>
<p>And we&rsquo;re back to our failing acceptance test. But we&rsquo;re not done with the refactor. Now we can change SelectQuery to map all the rows of the table through the filter method and no new tests should break!</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div></td><td class="code"><span class="k">class </span><span class="nc">SelectQuery</span>
  <span class="k">def </span><span class="nf">eval</span> <span class="n">database</span>
    <span class="n">database</span><span class="o">[</span><span class="n">from_table</span><span class="o">]</span><span class="nf">.map</span><span class="p">{</span><span class="o">|</span><span class="n">row</span><span class="o">|</span> <span class="n">args</span><span class="nf">.filter</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>
</td></tr></tbody></table></pre>
<p>Now our in-progress acceptance test is complaining in a new way that tells us what to do next.</p>
<pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div></td><td class="code">  1) Error:
test_0002_retrieves one column for all rows when only that column is specified(SQLAwesome):
NoMethodError: undefined method `filter&#39; for Fields:[eng]:SQLAwesome::SemanticModel::Field
</td></tr></tbody></table></pre>
<p>Let&rsquo;s add the filter method to Field. First the test:</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div><div class="lineno">6</div></td><td class="code">  <span class="n">it</span> <span class="s2">&quot;should filter out all but it&#39;s field&quot;</span> <span class="k">do</span>
    <span class="n">field</span> <span class="o">=</span> <span class="no">Field</span><span class="nf">.new</span> <span class="s2">&quot;a&quot;</span>
    <span class="n">original</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;a&quot;</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span><span class="s2">&quot;b&quot;</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">}</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">field</span><span class="nf">.filter</span> <span class="n">original</span>
    <span class="n">result</span><span class="nf">.must_equal</span> <span class="s2">&quot;a&quot;</span> <span class="o">=&gt;</span> <span class="mi">1</span>
  <span class="k">end</span>
</td></tr></tbody></table></pre>
<p>Implementation</p>
<pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div></td><td class="code">  <span class="k">def </span><span class="nf">filter</span> <span class="n">row</span>
    <span class="p">{</span><span class="nb">name</span> <span class="o">=&gt;</span> <span class="n">row</span><span class="o">[</span><span class="nb">name</span><span class="o">]</span><span class="p">}</span>
  <span class="k">end</span>
</td></tr></tbody></table></pre>
<p>Bam!</p>
<pre class="highlight text"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div><div class="lineno">5</div><div class="lineno">6</div><div class="lineno">7</div><div class="lineno">8</div><div class="lineno">9</div><div class="lineno">10</div></td><td class="code">$ rake
Run options: --seed 28160

# Running tests:

.............

Finished tests in 0.021960s, 591.9854 tests/s, 683.0601 assertions/s.

13 tests, 15 assertions, 0 failures, 0 errors, 0 skips
</td></tr></tbody></table></pre>
<h1>Multiple Fields</h1>
<pre class="highlight sql"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div></td><td class="code"><span class="k">SELECT</span> <span class="k">year</span><span class="p">,</span> <span class="n">name</span> <span class="k">FROM</span> <span class="n">hats</span>
</td></tr></tbody></table></pre><pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div></td><td class="code"><span class="no">SelectQuery</span><span class="nf">.new</span> <span class="no">Fields</span><span class="nf">.new</span><span class="p">(</span><span class="o">[</span><span class="s2">&quot;year&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="o">]</span><span class="p">),</span> <span class="no">From</span><span class="nf">.new</span><span class="p">(</span><span class="s2">&quot;hats&quot;</span><span class="p">)</span>
</td></tr></tbody></table></pre>
<h1>Single Element Where clauses</h1>

<h2>Numeric Equality</h2>
<pre class="highlight sql"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div></td><td class="code"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">one_to_five</span> <span class="k">WHERE</span> <span class="n">dec</span> <span class="o">=</span> <span class="mi">1</span>
</td></tr></tbody></table></pre><pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div></td><td class="code"><span class="no">SelectQuery</span><span class="nf">.new</span><span class="p">(</span><span class="no">WildCard</span><span class="nf">.new</span><span class="p">,</span>
                <span class="no">From</span><span class="nf">.new</span><span class="p">(</span><span class="s2">&quot;one_to_five&quot;</span><span class="p">),</span>
                <span class="no">Where</span><span class="nf">.new</span><span class="p">(</span>
                  <span class="no">NumericEquality</span><span class="nf">.new</span><span class="p">(</span><span class="s2">&quot;dec&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
</td></tr></tbody></table></pre>
<h2>String Equality</h2>
<pre class="highlight sql"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div></td><td class="code"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">one_to_five</span> <span class="k">WHERE</span> <span class="n">eng</span> <span class="o">=</span> <span class="nv">&quot;one&quot;</span>
</td></tr></tbody></table></pre><pre class="highlight ruby"><table><tbody><tr><td class="gutter gl"><div class="lineno">1</div><div class="lineno">2</div><div class="lineno">3</div><div class="lineno">4</div></td><td class="code"><span class="no">SelectQuery</span><span class="nf">.new</span><span class="p">(</span><span class="no">WildCard</span><span class="nf">.new</span><span class="p">,</span>
                <span class="no">From</span><span class="nf">.new</span><span class="p">(</span><span class="s2">&quot;one_to_five&quot;</span><span class="p">),</span>
                <span class="no">Where</span><span class="nf">.new</span><span class="p">(</span>
                  <span class="no">StringEquality</span><span class="nf">.new</span><span class="p">(</span><span class="s2">&quot;eng&quot;</span><span class="p">,</span> <span class="s2">&quot;one&quot;</span><span class="p">)))</span>
</td></tr></tbody></table></pre>
<h1>Where to go from here:</h1>

<ul>
<li>Language Features

<ul>
<li>Compound Where clauses (AND and OR).</li>
<li>Functions (COUNT(*))</li>
<li>Aliases (SELECT name AS real_name)</li>
<li>Joins</li>
<li>Indices / Query Planning</li>
</ul></li>
<li>Tooling

<ul>
<li>Better Error Messages for parsing / missing tables/columns.</li>
<li>Syntax highlighting.</li>
</ul></li>
</ul>

<h1>Further Reading</h1>

<ul>
<li><a href="http://kschiess.github.io/parslet/documentation.html">Parslet Documentation</a></li>
<li>Domain Specific Languages - Martin Fowler <a href="http://martinfowler.com/books/dsl.html">martinfowler.com</a></li>
<li>Growing Object Oriented Software, Guided by Tests <a href="http://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627">amazon.com</a></li>
</ul>

    <script src="../js/viz.js" type="text/javascript"></script>
<script src="../js/viz_helper.js" type="text/javascript"></script>
    <script type="text/javascript">
      Vizzy();
    </script>
  </body>
</html>